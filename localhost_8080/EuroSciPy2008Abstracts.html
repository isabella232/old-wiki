<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!-- Mirrored from localhost:8080/EuroSciPy2008Abstracts by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 29 Oct 2015 20:25:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="edit_on_doubleclick" content="/">
<meta name="robots" content="index,nofollow">

<title>EuroSciPy2008Abstracts - SciPy</title>
<script type="text/javascript" src="moin_static197/common/js/common.js"></script>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="moin_static197/modern/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="moin_static197/modern/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="moin_static197/modern/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="moin_static197/modern/css/projection.css">

<!-- css only for MS IE6/IE7 browsers -->
<!--[if lt IE 8]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/moin_static197/modern/css/msie.css">
<![endif]-->


<link rel="alternate" title="SciPy: EuroSciPy2008Abstracts" href="../external.html?link=http://localhost:8080/EuroSciPy2008Abstracts?diffs=1&amp;show_att=1&amp;action=rss_rc&amp;unique=0&amp;page=EuroSciPy2008Abstracts&amp;ddiffs=1" type="application/rss+xml">


<link rel="Start" href="AllPages.html">
<link rel="Alternate" title="Wiki Markup" href="../external.html?link=http://localhost:8080/EuroSciPy2008Abstracts?action=raw">
<link rel="Alternate" media="print" title="Print View" href="../external.html?link=http://localhost:8080/EuroSciPy2008Abstracts?action=print">
<link rel="Search" href="FindPage.html">
<link rel="Index" href="TitleIndex.html">
<link rel="Glossary" href="WordIndex.html">
<link rel="Help" href="HelpOnFormatting.html">
</head>

<body  lang="en" dir="ltr">

<div id="header">


<form id="searchform" method="get" action="../external.html?link=http://localhost:8080/EuroSciPy2008Abstracts">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20"
    onfocus="searchFocus(this)" onblur="searchBlur(this)"
    onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search">
<input id="titlesearch" name="titlesearch" type="submit"
    value="Titles" alt="Search Titles">
<input id="fullsearch" name="fullsearch" type="submit"
    value="Text" alt="Search Full Text">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<ul id="username"><li><a href="EuroSciPy2008Abstracts456e.html?action=login" id="login" rel="nofollow">Login</a></li></ul>
<div id="locationline">
<div id="interwiki"><span><a href="AllPages.html" rel="nofollow">SciPy</a></span></div>

<ul id="pagelocation">
<li><a class="backlink" href="AllPagescc4f.html?action=fullsearch&amp;context=180&amp;value=linkto%3A%22EuroSciPy2008Abstracts%22" rel="nofollow" title="Click to do a full-text search for this title">EuroSciPy2008Abstracts</a></li>
</ul>

</div>


<ul id="navibar">
<li class="wikilink"><a href="RecentChanges.html">RecentChanges</a></li><li class="wikilink"><a class="nonexistent" href="FindPage.html">FindPage</a></li><li class="wikilink"><a class="nonexistent" href="HelpContents.html">HelpContents</a></li><li class="current"><a href="EuroSciPy2008Abstracts.html">EuroSciPy2008Abstracts</a></li>
</ul>

<div id="pageline"><hr style="display:none;"></div>

<ul class="editbar"><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbattachments" href="EuroSciPy2008Abstracts37dc.html?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="../external.html?link=http://localhost:8080/EuroSciPy2008Abstracts">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Subscribe User</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867">
<h1 id="Abstracts_of_EuroScipy2008">Abstracts of EuroScipy2008</h1>
<span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><p class="line867"><span class="anchor" id="kmueller"></span> <span class="anchor" id="line-4"></span>
<h2 id="SimPy.2C_a_discrete_event_simulation_package_in_Python">SimPy, a discrete event simulation package in Python</h2>
<span class="anchor" id="line-5"></span><span class="anchor" id="line-6"></span><p class="line867"><strong> by: Klaus G. Müller </strong> <span class="anchor" id="line-7"></span><span class="anchor" id="line-8"></span><p class="line862">The presentation will address SimPy (Simulation in Python), <span class="anchor" id="line-9"></span>an Open Source discrete event simulation package. It is <span class="anchor" id="line-10"></span>written completely in Python. SimPy is released under a LGPL <span class="anchor" id="line-11"></span>license and can be downloaded free of charge from <a class="http" href="../external.html?link=http://sourceforge.net/project/showfiles.php?group_id=62366">http://sourceforge.net/project/showfiles.php?group_id=62366</a>. <span class="anchor" id="line-12"></span>The SimPy website <a class="http" href="../external.html?link=http://simpy.sourceforge.net/">http://simpy.sourceforge.net</a> describes the <span class="anchor" id="line-13"></span>package in detail and provides extensive user documentation. <span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><p class="line867">SimPy is being used for teaching and research purposes at <span class="anchor" id="line-16"></span>universities in several countries. Many companies and institutes <span class="anchor" id="line-17"></span>also use it for simulation studies. <span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span><p class="line862">The talk describes the basic philosophy and design of SimPy. <span class="anchor" id="line-20"></span>SimPy is modeled after the Simula67 simulation language, but goes <span class="anchor" id="line-21"></span>beyond that language’s capabilities in terms of simulation constructs <span class="anchor" id="line-22"></span>and extensibility.  It is a process-oriented simulation package, i.e., <span class="anchor" id="line-23"></span>the lifecycle of a simulation entity and all its events are described <span class="anchor" id="line-24"></span>in one method (called the Process Execution Method). Processes are <span class="anchor" id="line-25"></span>implemented as Python generators.  Process scheduling is done by yield <span class="anchor" id="line-26"></span>statements with parameters. This provides semi-coroutines, light-weight <span class="anchor" id="line-27"></span>threads which run in pseudo-concurrency.  <span class="anchor" id="line-28"></span><span class="anchor" id="line-29"></span><p class="line862">Various small examples of SimPy programs will be presented and run <span class="anchor" id="line-30"></span>to show the range of process control constructs, and also to illustrate <span class="anchor" id="line-31"></span>how concisely and descriptively models can be programmed in SimPy. <span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><p class="line862">The various run-modes of SimPy (which include event tracing, event-by-event <span class="anchor" id="line-34"></span>execution, and synchronization between wall-clock and simulation time) will <span class="anchor" id="line-35"></span>be described and run, as will be the GUI and plotting libraries included. <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line862">The talk will conclude with a few words about the relationship between SimPy <span class="anchor" id="line-38"></span>and SciPy.  <span class="anchor" id="line-39"></span><span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line867"><span class="anchor" id="jmartinek1"></span> <span class="anchor" id="line-42"></span>
<h2 id="Coefficient_of_restitution_measurement_using_a_soundcard">Coefficient of restitution measurement using a soundcard</h2>
<span class="anchor" id="line-43"></span><span class="anchor" id="line-44"></span><p class="line867"><strong> by: Jan Martinek </strong> <span class="anchor" id="line-45"></span><span class="anchor" id="line-46"></span><p class="line874">Coefficient of restitution (COR) is a measure of elasticity of <span class="anchor" id="line-47"></span>collision between two bodies. This article presents a method for <span class="anchor" id="line-48"></span>measurement of the coefficient of restitution between bouncing a rubber <span class="anchor" id="line-49"></span>ball and a hard surface. Each impact makes a sound which is detected <span class="anchor" id="line-50"></span>by a microphone connected to computer's sound card and the <span class="anchor" id="line-51"></span>recorded sound is analysed. Coefficient of restitution is calculated <span class="anchor" id="line-52"></span>from the delays between each two consecutive impacts. Programs <span class="anchor" id="line-53"></span>listed and commented in the article utilises Python with the <span class="anchor" id="line-54"></span>python‑alsaaudio library for sound recording, !Scipy for data <span class="anchor" id="line-55"></span>processing and matplotlib for waveform visualisation. It runs under the <span class="anchor" id="line-56"></span>Linux operating system and a whole experiment is meant primarily for <span class="anchor" id="line-57"></span>students and education purposes. <span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><p class="line867"><span class="anchor" id="jmartinek2"></span> <span class="anchor" id="line-61"></span>
<h2 id="Musical_instrument_tuner_and_tone_analysis">Musical instrument tuner and tone analysis</h2>
<span class="anchor" id="line-62"></span><span class="anchor" id="line-63"></span><p class="line867"><strong> by: Jan Martinek </strong> <span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><p class="line874">This article presents an implementation of well known method for <span class="anchor" id="line-66"></span>fundamental frequency measurement. The algorithm uses FFT and <span class="anchor" id="line-67"></span>searches for a peak in spectrum. Dominant frequency is then <span class="anchor" id="line-68"></span>recalculated to tone name used in music. The presented computer <span class="anchor" id="line-69"></span>program basically works in similar way to commercially sold tuners <span class="anchor" id="line-70"></span>for musical instruments and also many other software tuners widely <span class="anchor" id="line-71"></span>available in the internet, but what makes it unique is the peak <span class="anchor" id="line-72"></span>search algorithm and reliable matching of higher harmonics. Moreover, <span class="anchor" id="line-73"></span>the programme is written in Python programming language with a great <span class="anchor" id="line-74"></span>help of !Scipy. This makes it surprisingly simple to implement and <span class="anchor" id="line-75"></span>easy to understand and modify. It runs under Linux and uses alsa <span class="anchor" id="line-76"></span>for sound recording. <span class="anchor" id="line-77"></span><span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span><p class="line867"><span class="anchor" id="bvoigt"></span> <span class="anchor" id="line-80"></span>
<h2 id="Searching_High_Energy_Neutrinos_with_IceCube_and_Python">Searching High Energy Neutrinos with IceCube and Python</h2>
<span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><p class="line867"><strong>by: Bernhard Voigt</strong> <span class="anchor" id="line-83"></span><span class="anchor" id="line-84"></span><p class="line862">The IceCube neutrino telescope is currently constructed in the deep ice near the <span class="anchor" id="line-85"></span>geographic South Pole. At completion IceCube will consist of more than <span class="anchor" id="line-86"></span>4500 photomultiplier tubes which record the Cherenkov light from <span class="anchor" id="line-87"></span>secondary charged particles produced in neutrino nucleon interactions, <span class="anchor" id="line-88"></span>in order to detect high energy neutrinos coming from cosmological <span class="anchor" id="line-89"></span>objects. The recorded signals are used to reconstruct the energy and <span class="anchor" id="line-90"></span>direction of the incident neutrino. The core of the custom made <span class="anchor" id="line-91"></span>software components, ranging from simulation to data compression and <span class="anchor" id="line-92"></span>likelihood reconstruction is written in C++. The program flow <span class="anchor" id="line-93"></span>structures are exposed to Python using Boost.Python. This allows to <span class="anchor" id="line-94"></span>control the data processing flow in Python which offers a great <span class="anchor" id="line-95"></span>flexibility. Data analyses can be performed using Python and libraries <span class="anchor" id="line-96"></span>like numpy, scipy, matplotlib, pytables and pyROOT. For this purpose <span class="anchor" id="line-97"></span>the main data structures are exposed to Python, as well. The talk will <span class="anchor" id="line-98"></span>give an overview about the control flow of the IceCube software chain, <span class="anchor" id="line-99"></span>driven by Python, and how reconstructed data is analysed using Python <span class="anchor" id="line-100"></span>and extension libraries. <span class="anchor" id="line-101"></span><span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><p class="line867"><span class="anchor" id="ppeterson"></span> <span class="anchor" id="line-104"></span>
<h2 id="On_providing_a_Computer_Algebra_System_for_Python">On providing a Computer Algebra System for Python</h2>
<span class="anchor" id="line-105"></span><span class="anchor" id="line-106"></span><p class="line867"><strong>by: Pearu Peterson</strong> <span class="anchor" id="line-107"></span><span class="anchor" id="line-108"></span><p class="line874">During the last ten years there has been many attempts to <span class="anchor" id="line-109"></span>provide a Computer Algebra System (CAS) for Python that have important <span class="anchor" id="line-110"></span>applications in code generation tools, for example.  In most cases, <span class="anchor" id="line-111"></span>one of the following approaches has been proposed: wrap existing CAS <span class="anchor" id="line-112"></span>libraries to Python, create Python interfaces to existing CAS <span class="anchor" id="line-113"></span>programs, or implement pure Python CAS from scratch.  In this talk I <span class="anchor" id="line-114"></span>will discuss pros and cons of these approaches as well as try to give <span class="anchor" id="line-115"></span>an overview of what is the current state with CAS-s for Python. <span class="anchor" id="line-116"></span>Finally, a pure Python package, sympycore, will be introduced as <span class="anchor" id="line-117"></span>sufficiently efficient and robust implementation of a CAS for Python. <span class="anchor" id="line-118"></span>For example, the sympycore speed is comparable with the speed of many <span class="anchor" id="line-119"></span>CAS-s that are implemented using a compiled language. <span class="anchor" id="line-120"></span><span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><p class="line867"><span class="anchor" id="jmrohwer"></span>    <span class="anchor" id="line-123"></span>
<h2 id="Python.2C_Systems_Biology_and_PySCeS">Python, Systems Biology and PySCeS</h2>
<span class="anchor" id="line-124"></span><span class="anchor" id="line-125"></span><p class="line874">by: Johann M. Rohwer, Brett G. Olivier, and Jan-Hendrik S. Hofmeyr <span class="anchor" id="line-126"></span><span class="anchor" id="line-127"></span><p class="line867"><strong>Introduction</strong> <span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><p class="line874">Computer modelling has become an integral tool in the analysis and <span class="anchor" id="line-130"></span>understanding of the reaction networks that underlie cellular processes. <span class="anchor" id="line-131"></span>Programs such as the Systems <a class="http" href="../external.html?link=http://dx.doi.org/10.1089/153623103322637670">BiologyWorkbench</a> <span class="anchor" id="line-132"></span>(SBW) and <a class="http" href="../external.html?link=http://bioinformatics.oxfordjournals.org/cgi/content/abstract/22/24/3067">COPASI</a> <span class="anchor" id="line-133"></span>allow us to simulate the behaviour of these reaction networks; each <span class="anchor" id="line-134"></span>has its advantages and limitations. The need to adapt modelling software <span class="anchor" id="line-135"></span>to our specific needs prompted the development of <a class="http" href="../external.html?link=http://pysces.sourceforge.ne/">PySCeS</a>, the Python Simulator for Cellular Systems, which we present here. <span class="anchor" id="line-136"></span>PySCeS is an extremely exible, user-extensible, open-source modelling tool. <span class="anchor" id="line-137"></span>Development started in 2000, with the first public release following in 2004. <span class="anchor" id="line-138"></span>PySCeS is written in Python and makes extensive use of the highly successful <span class="anchor" id="line-139"></span>IPython, NumPy, SciPy, Matplotlib stack. It has been developed to run on both <span class="anchor" id="line-140"></span>Microsoft Windows and Linux (with a Mac OS X port possible in principle) and is <span class="anchor" id="line-141"></span>currently released under the GNU GPL licence. <span class="anchor" id="line-142"></span><span class="anchor" id="line-143"></span><p class="line867"><strong>PySCeS: core</strong> <span class="anchor" id="line-144"></span><span class="anchor" id="line-145"></span><p class="line874">Models are initially described as PySCeS input files in a human readable <span class="anchor" id="line-146"></span>model description language (MDL). We have implemented a MDL parser using <span class="anchor" id="line-147"></span>David Beazley's PLY. Alternatively, PySCeS supports translation to and <span class="anchor" id="line-148"></span>from the <a class="http" href="../external.html?link=http://www.sbml.org/">Systems Biology Markup Language (SBML)</a>, <span class="anchor" id="line-149"></span>the de facto standard for model exchange. <span class="anchor" id="line-150"></span>Once a PySCeS model object has been instantiated with an input file, <span class="anchor" id="line-151"></span>all model properties are represented by attributes. Specifically, the kinetic <span class="anchor" id="line-152"></span>rate equations are represented by rate equation objects. During the load process <span class="anchor" id="line-153"></span>a stoichiometric analysis is automatically performed, thus generating the <span class="anchor" id="line-154"></span>ordinary differential equations (ODEs) describing the system. <span class="anchor" id="line-155"></span>After translation into ODEs the system can be analysed with a number of algorithms <span class="anchor" id="line-156"></span>in terms of its time-dependent (LSODA, CVODE) and steady-state (HYBRD, NLEQ2, KINSOL) <span class="anchor" id="line-157"></span>solutions. <span class="anchor" id="line-158"></span>PySCeS also allows higher level system properties to be analysed using <span class="anchor" id="line-159"></span>Metabolic Control Analysis, a theoretical framework for the study of the control <span class="anchor" id="line-160"></span>and regulatory properties of a cellular reaction network at steady state. <span class="anchor" id="line-161"></span>The stability of the system can be evaluated by automatic computation of the <span class="anchor" id="line-162"></span>eigenvalues of the Jacobian matrix. <span class="anchor" id="line-163"></span><span class="anchor" id="line-164"></span><p class="line867"><strong>PySCeS in operation</strong> <span class="anchor" id="line-165"></span><span class="anchor" id="line-166"></span><p class="line874">As an example of how we use PySCeS in systems biology we will show how <span class="anchor" id="line-167"></span>multiple-parameter rate characteristics can be used to investigate bistable <span class="anchor" id="line-168"></span>regulatory patterns in an example metabolic pathway and how regulatory <span class="anchor" id="line-169"></span>metabolites can be computationally identified from a  <a class="http" href="../external.html?link=http://dx.doi.org/10.1016/j.jtbi.2007.10.032">generalised supply-demand analysis</a>. <span class="anchor" id="line-170"></span>Exciting bleeding-edge developments include PySCeS/Kraken and PySCeS/Mariner. <span class="anchor" id="line-171"></span>Kraken is our first attempt at using PySCeS in a distributed environment <span class="anchor" id="line-172"></span>and employs a single master, multiple client design that allows for the <span class="anchor" id="line-173"></span>distribution of embarrassingly parallel problems over a heterogeneous grid of CPUs. PySCeS/Mariner provides a web-application framework (using Optio's soaplib) <span class="anchor" id="line-174"></span>to expose PySCeS functionality on the one hand and consume SOAP-based <span class="anchor" id="line-175"></span>web-services (e.g. SBW) on the other hand. <span class="anchor" id="line-176"></span><span class="anchor" id="line-177"></span><span class="anchor" id="line-178"></span><p class="line867"><span class="anchor" id="adalke"></span> <span class="anchor" id="line-179"></span>
<h2 id="Python_Tools_in_Computational_Chemistry">Python Tools in Computational Chemistry</h2>
<span class="anchor" id="line-180"></span><span class="anchor" id="line-181"></span><p class="line867"><strong>by: Andrew Dahlke</strong> <span class="anchor" id="line-182"></span><span class="anchor" id="line-183"></span><p class="line874">For the last 13 years I've been a professional software developer in <span class="anchor" id="line-184"></span>computational chemistry and related fields, and mostly in chemical <span class="anchor" id="line-185"></span>informatics, molecular modeling, and bioinformatics.  I develop <span class="anchor" id="line-186"></span>scientific software but it often seems distant from what others <span class="anchor" id="line-187"></span>do at SciPy.  For example, I import the numeric libraries about every <span class="anchor" id="line-188"></span>time there's a name change.  The science behind what I work on is <span class="anchor" id="line-189"></span>more often based on graph theory than on matrices. <span class="anchor" id="line-190"></span><span class="anchor" id="line-191"></span><p class="line874">Thankfully Python is popular in computational chemistry and there are <span class="anchor" id="line-192"></span>a good number of chemistry tools for Python available, including the <span class="anchor" id="line-193"></span>OpenEye toolkits and OpenBabel, so I don't often have to work on the <span class="anchor" id="line-194"></span>low-level details.  Much of what I do is tool and algorithm integration, <span class="anchor" id="line-195"></span>which often means wrapping yet another program and figuring out how it <span class="anchor" id="line-196"></span>breaks, or writing yet another specialized format parser. <span class="anchor" id="line-197"></span><span class="anchor" id="line-198"></span><p class="line874">In my presentation I'll summarize some of the reasons I think Python <span class="anchor" id="line-199"></span>became the dominant high-level language in computational chemistry, <span class="anchor" id="line-200"></span>some of the algorithms and data types which are important to this field, <span class="anchor" id="line-201"></span>and a few of the key projects. <span class="anchor" id="line-202"></span><span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><p class="line867"><span class="anchor" id="mmueller"></span> <span class="anchor" id="line-205"></span>
<h2 id="PyModelData_-_Easy_Data_Input_for_Scientific_Simulation_Models">PyModelData - Easy Data Input for Scientific Simulation Models</h2>
<span class="anchor" id="line-206"></span><span class="anchor" id="line-207"></span><p class="line867"><strong> by: Mike Müller and Stefan Schwarzer</strong> <span class="anchor" id="line-208"></span><span class="anchor" id="line-209"></span><p class="line874">Processing of input data for simulation models can be a major <span class="anchor" id="line-210"></span>effort. The Python library <a class="http" href="../external.html?link=http://www.pymodeldata.org/">PyModelData</a> <span class="anchor" id="line-211"></span>provides many features to aid the model programmer as well as the <span class="anchor" id="line-212"></span>model user. User input is transferred directly into data structures <span class="anchor" id="line-213"></span>of the programming language Python without the need to write code. <span class="anchor" id="line-214"></span>PyModelData is based on <a class="http" href="../external.html?link=http://www.yaml.org/">YAML</a> which offers an <span class="anchor" id="line-215"></span>input format readable by humans and machines alike. PyModelData <span class="anchor" id="line-216"></span>extends this format to allow nesting of files, thus separating <span class="anchor" id="line-217"></span>frequently changed from other data. Moreover, the included files <span class="anchor" id="line-218"></span>can have other formats such as CSV, Excel, dBase or HDF. <span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span><p class="line874">An application user writes an input data file in YAML format <span class="anchor" id="line-221"></span>while an application programmer may add a declarative input <span class="anchor" id="line-222"></span>description with units, valid ranges and other meta-information <span class="anchor" id="line-223"></span>which is applied after parsing the user's data. <span class="anchor" id="line-224"></span><span class="anchor" id="line-225"></span><p class="line867">PyModelData has been used successfully for two simulation models. <span class="anchor" id="line-226"></span>Users seem to grasp the library quickly and become productive <span class="anchor" id="line-227"></span>after a short learning period. <span class="anchor" id="line-228"></span><span class="anchor" id="line-229"></span><p class="line874">It is planned to add a GUI interface that generates its views <span class="anchor" id="line-230"></span>automatically from the declarative template file. This means <span class="anchor" id="line-231"></span>getting a simple yet useful GUI without any work except <span class="anchor" id="line-232"></span>specifying the input data.  <span class="anchor" id="line-233"></span><span class="anchor" id="line-234"></span><span class="anchor" id="line-235"></span><p class="line867"><span class="anchor" id="mcroettger"></span>  <span class="anchor" id="line-236"></span>
<h2 id="How_to_decide_-_Machine_Learning_with_Python">How to decide - Machine Learning with Python</h2>
<span class="anchor" id="line-237"></span><span class="anchor" id="line-238"></span><p class="line867"><strong>by: Michael C. Röttger and Andreas W. Liehr</strong> <span class="anchor" id="line-239"></span><span class="anchor" id="line-240"></span><p class="line874">In Reinforcement Learning, one solves optimal control problems <span class="anchor" id="line-241"></span>without knowledge of the underlying system's dynamics from the following <span class="anchor" id="line-242"></span>perspective: An agent, who is aware of the current state of his environment, <span class="anchor" id="line-243"></span>decides in favour of a particular action. The action is performed <span class="anchor" id="line-244"></span>resulting in a change of the agent's environment. The <span class="anchor" id="line-245"></span>agent notices the new state, receives a reward and decides again. <span class="anchor" id="line-246"></span>This process repeats over and over and may be terminated by reaching a terminal <span class="anchor" id="line-247"></span>state. In the course of time the agent learns from his <span class="anchor" id="line-248"></span>experience by developing a strategy which maximizes his estimated total reward. <span class="anchor" id="line-249"></span><span class="anchor" id="line-250"></span><p class="line874">The overall research in Reinforcement Learning concentrates on discrete sets of <span class="anchor" id="line-251"></span>actions, but for real world problems it would be nice to have methods <span class="anchor" id="line-252"></span>which are able to find good strategies using actions drawn from <span class="anchor" id="line-253"></span>continuous sets, e.g. when you have to decide for a spatial direction <span class="anchor" id="line-254"></span>in order to reach a distant point by going a minimal number of steps. <span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><p class="line874">We're using Python for searching and comparing strategies by <span class="anchor" id="line-257"></span>evaluating combinations of different Reinforcement Learning <span class="anchor" id="line-258"></span>algorithms, control tasks and requirements. <span class="anchor" id="line-259"></span>In this talk, we give an overview of our implementation <span class="anchor" id="line-260"></span>pointing out the contexts in which SciPy and other Python packages are applied.  <span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><span class="anchor" id="line-263"></span><p class="line867"><span class="anchor" id="dalbanese"></span>  <span class="anchor" id="line-264"></span>
<h2 id="mlpy_-_Machine_Learning_Py_-_A_High-Performance_Python.2FNumPy_Based_Package_for_Machine_Learning">mlpy - Machine Learning Py - A High-Performance Python/NumPy Based Package for Machine Learning</h2>
<span class="anchor" id="line-265"></span><span class="anchor" id="line-266"></span><p class="line867"><strong>by: Davide Albanese, Stefano Merler, Giuseppe Jurman, Roberto Visintainer, <span class="anchor" id="line-267"></span>Samantha Riccadonna, Silvano Paoli, Cesare Furlanello, and Fondazione Bruno Kessler</strong> <span class="anchor" id="line-268"></span><span class="anchor" id="line-269"></span><p class="line874">Obtaining honest performance estimates from a machine learning experiment usually <span class="anchor" id="line-270"></span>requires fulfilling a complex pipeline of simpler tasks. Those steps can be <span class="anchor" id="line-271"></span>organized inside a Data Analysis Protocol (DAP) tailored by the researcher as <span class="anchor" id="line-272"></span>suitable for the investigated problem typically a predictive classification or <span class="anchor" id="line-273"></span>regression task. As a very basic example, a binary classification experiment can <span class="anchor" id="line-274"></span>be structured by a k-fold cross-validation with internal feature ranking performed <span class="anchor" id="line-275"></span>at each split. We propose mlpy as an Open Source package collecting several modules; <span class="anchor" id="line-276"></span>they implement different flavours of the machine learning functions required in <span class="anchor" id="line-277"></span>each classification, feature-ranking and feature-listsanalysis experiment. <span class="anchor" id="line-278"></span>In particular, mlpy provides high level procedures which guarantee high modularity <span class="anchor" id="line-279"></span>and ease of use. These features allow researchers, even those not particularly <span class="anchor" id="line-280"></span>inclined to programming, to construct their own methodological procedure still <span class="anchor" id="line-281"></span>mantaining good computational efficiency. <span class="anchor" id="line-282"></span>Although mlpy is suited for general-purpose machine learning tasks, its elective <span class="anchor" id="line-283"></span>application field is bioinformatics and, in particular, the analysis of <span class="anchor" id="line-284"></span>high-throughput data such as genomics and proteomics, where input data can easily <span class="anchor" id="line-285"></span>reach dimensions of thousands of samples described up to onemillion of features <span class="anchor" id="line-286"></span>(e.g. SNPs array data). Furthermore, we can use modularity to alleviate the <span class="anchor" id="line-287"></span>computational burden by distributing the processes on a HPC facility such as a <span class="anchor" id="line-288"></span>cluster or a grid infrastructure. The modular structure of mlpy allows easily adding <span class="anchor" id="line-289"></span>new algorithms in each category. <span class="anchor" id="line-290"></span>The mlpy package makes an intensive use of the NumPy module: its strong support <span class="anchor" id="line-291"></span>for integration with C code has allowed us to implement as internal C functions <span class="anchor" id="line-292"></span>the parts with higher computational costs. The main features of mlpy can be divided <span class="anchor" id="line-293"></span>into several groups according to their goal, as detailed in the following lists <span class="anchor" id="line-294"></span>(for beta version 1.2.5): <span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><dl><dt>Classification</dt><dd>For each classifier, distinct methods are deployed for the <span class="anchor" id="line-297"></span>training and the testing phases. Whenever possible, the real valued prediction can be <span class="anchor" id="line-298"></span>obtained. The implemented algorithms are in the families of SVMs-Support Vector <span class="anchor" id="line-299"></span>Machines (four kernels avaiable), DA-Discriminant Analysis (Fisher and Spectral <span class="anchor" id="line-300"></span>Regression) and Nearest Neighbours. <span class="anchor" id="line-301"></span><span class="anchor" id="line-302"></span></dd><dt>Feature weighting</dt><dd>In addition to feature weights coming directly from <span class="anchor" id="line-303"></span>classifiers such as SVMs or DAs, classifier-independent methods for weighting <span class="anchor" id="line-304"></span>features are also implemented: I-RELIEF and Discrete Wavelet Transform <span class="anchor" id="line-305"></span>(four a total of nine methods). <span class="anchor" id="line-306"></span><span class="anchor" id="line-307"></span></dd><dt>Feature ranking</dt><dd>Two main schemas are used for selecting and ranking <span class="anchor" id="line-308"></span>purposes, belonging either to the Recursive Feature Elimination or the <span class="anchor" id="line-309"></span>Recursive Forward Selection family (for a total of six variants). <span class="anchor" id="line-310"></span><span class="anchor" id="line-311"></span></dd><dt>Resampling methods</dt><dd>The classification and feature ranking operations <span class="anchor" id="line-312"></span>can be organized within a sampling procedure such as Textbook/Monte-Carlo <span class="anchor" id="line-313"></span>cross validation, leave-one-out or user-defined train/test split schema. <span class="anchor" id="line-314"></span>Stratification over lables is also available. <span class="anchor" id="line-315"></span><span class="anchor" id="line-316"></span></dd><dt>Metric functions</dt><dd>Performance assessment can be evaluated by a set of <span class="anchor" id="line-317"></span>different measures with variability assessed by Standard Deviation or <span class="anchor" id="line-318"></span><span class="anchor" id="line-319"></span>Bootstrap Confidence Intervals: among those we mention Error, Accuracy, <span class="anchor" id="line-320"></span>Matthews Correlation Coefficient, Area Under the ROC Curve. <span class="anchor" id="line-321"></span><span class="anchor" id="line-322"></span></dd><dt>Feature list analysis</dt><dd>The ordered lists from the feature ranking experiments <span class="anchor" id="line-323"></span>can be analyzed in terms of stability (Canberra indicator, extraction/position <span class="anchor" id="line-324"></span>indicator) and an optimal list can be retrieved <span class="anchor" id="line-325"></span><p class="line891"><a class="http" href="../external.html?link=http://biodcv.fbk.eu/listspy.html">Borda count</a>. <span class="anchor" id="line-326"></span><span class="anchor" id="line-327"></span></dd><dt>Landscaping tools</dt><dd>The package includes executable scripts to be used <span class="anchor" id="line-328"></span>off-the-shelf for typical parameter tuning tasks such as SVM-kernel <span class="anchor" id="line-329"></span>choice and optimization. <span class="anchor" id="line-330"></span><span class="anchor" id="line-331"></span></dd></dl><p class="line867"><a class="https" href="../external.html?link=https://mlpy.fbk.eu/">mlpy</a> is a project developed by <a class="http" href="../external.html?link=http://mpba.fbk.eu/">MPBA Group</a> <span class="anchor" id="line-332"></span>at <a class="http" href="../external.html?link=http://www.fbk.eu/">Fondazione Bruno Kessler</a>. <span class="anchor" id="line-333"></span>It is free software licensed under the GNU General Public License (GPL) version 3. <span class="anchor" id="line-334"></span><span class="anchor" id="line-335"></span><span class="anchor" id="line-336"></span><p class="line867"><span class="anchor" id="kzimmermann"></span> <span class="anchor" id="line-337"></span>
<h2 id="Rapid_Information_Processing_Based_on_Self-Documented_Primary_Data">Rapid Information Processing Based on Self-Documented Primary Data</h2>
<span class="anchor" id="line-338"></span><span class="anchor" id="line-339"></span><p class="line867"><strong>by: Klaus Zimmermann, Michael C. Röttger, Martin Kühne, Kristian Sylvester-Hvid, <span class="anchor" id="line-340"></span>Rico Schüppel, Moritz Riede, Andreas W. Liehr</strong> <span class="anchor" id="line-341"></span><span class="anchor" id="line-342"></span><p class="line874">The bottleneck for communicating scientific primary data is <span class="anchor" id="line-343"></span>the lack of a standard for simple tabular data sets. While <span class="anchor" id="line-344"></span>complex binary data sets can be stored comfortably with the <span class="anchor" id="line-345"></span>Hierarchical Data Format (HDF5) or the Network <span class="anchor" id="line-346"></span>Common Data Format (netCDF) these formats burden too much <span class="anchor" id="line-347"></span>overhead for small tabular data sets. The consequence is, <span class="anchor" id="line-348"></span>that most scientists save their data in text files <span class="anchor" id="line-349"></span>consisting of non-annotated bare columns of numbers. <span class="anchor" id="line-350"></span>Because these data files are always written in the <span class="anchor" id="line-351"></span>scientist's personal data format, which is rarely <span class="anchor" id="line-352"></span>documented, the primary data is very often become lost <span class="anchor" id="line-353"></span>after finishing the project. This continuously results in <span class="anchor" id="line-354"></span>the recreation of primary data and thus unnecessary extra <span class="anchor" id="line-355"></span>work. <span class="anchor" id="line-356"></span><span class="anchor" id="line-357"></span><p class="line874">In order to overcome this problem, we have invented the <span class="anchor" id="line-358"></span>Full Metadata Format (FMF), which is a text based format <span class="anchor" id="line-359"></span>taking into account the most basic needs of the average <span class="anchor" id="line-360"></span>scientist. The grammar of FMF has been formallyformaly <span class="anchor" id="line-361"></span>specified  with ANTLR and has been integrated into the <span class="anchor" id="line-362"></span>Pyphant data analysis framework. This allows us to <span class="anchor" id="line-363"></span>demonstrate the increase in research performance arising <span class="anchor" id="line-364"></span>from the simple fact, that primary data is stored in a <span class="anchor" id="line-365"></span>standardised way together with its meta data. The examples <span class="anchor" id="line-366"></span>comprise the automatic visualization of data files with <span class="anchor" id="line-367"></span>publication ready labelled diagrams, analysise of data sets <span class="anchor" id="line-368"></span>with unit and error propagation, as well as automated data <span class="anchor" id="line-369"></span>interpretation, which gives rise to new machine learning <span class="anchor" id="line-370"></span>paradigmsparadigma for natural and engineering sciences.  <span class="anchor" id="line-371"></span><span class="anchor" id="line-372"></span><span class="anchor" id="line-373"></span><p class="line867"><span class="anchor" id="avesquivel"></span>           <span class="anchor" id="line-374"></span>
<h2 id="Intensive_Python_for_Meshless_Simulation">Intensive Python for Meshless Simulation</h2>
<span class="anchor" id="line-375"></span><span class="anchor" id="line-376"></span><p class="line867"><strong>by: Alcides Viamontes Esquivel</strong> <span class="anchor" id="line-377"></span><span class="anchor" id="line-378"></span><p class="line874">Meshless methods are an emerging group of techniques for cutting edge PDE <span class="anchor" id="line-379"></span>simulation, at problems where conventional Finite Element Method (FEM) <span class="anchor" id="line-380"></span>falls short. In contraposition with FEM, Meshless evolved quite recently, in the <span class="anchor" id="line-381"></span>Pythonic Age, long decades after the Spread of Fortran which at its moment <span class="anchor" id="line-382"></span>gave raise to old good FEM. <span class="anchor" id="line-383"></span>&quot;NOMS&quot;, our framework for meshless simulation is built around two basic <span class="anchor" id="line-384"></span>pillars: first, scientific computing have to be possible and enjoyable for non <span class="anchor" id="line-385"></span>hard-core programmers, and second, fun should not sacrifice performance. <span class="anchor" id="line-386"></span>This presentation is about the hat of tricks we have used to achieve those goals: <span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><ul><li>Python let us code smarter routines in terms of how they process client <span class="anchor" id="line-389"></span>input. It’s also the language where the general, outer workflow of the <span class="anchor" id="line-390"></span>application gets coded. That’s good both for the developers and for the <span class="anchor" id="line-391"></span>users of the framework. <span class="anchor" id="line-392"></span></li><li>As usual, inner and expensive loops are implemented in a compiled language. <span class="anchor" id="line-393"></span>We use C++ through Boost.Python. The numpy array class is <span class="anchor" id="line-394"></span>powerful and Python-friendly, so many Python and C++ routines can accept <span class="anchor" id="line-395"></span>their instances as input. There’s also a simple sparse matrix class <span class="anchor" id="line-396"></span>implemented in C++ and some bindings for Boost.UBLAS, the TAUCS <span class="anchor" id="line-397"></span>symmetric solver and the UMFPACK library for sparse systems. <span class="anchor" id="line-398"></span></li><li>The nice trick in the realms of interoperability is the use of C++ STL template <span class="anchor" id="line-399"></span>instantiations from Python. Through some extensions and adaptations <span class="anchor" id="line-400"></span>of Boost.Python, that’s achieved in a uniform and automatic way. It <span class="anchor" id="line-401"></span>allows, among other things, to use the ecient STL ordered map from <span class="anchor" id="line-402"></span>Python, both for fixed combinations of key and value type in C++ or for <span class="anchor" id="line-403"></span>the scripting Python object. The implementation wrapper exposes the <span class="anchor" id="line-404"></span>usual dictionary interface and also allows the client to do both range and <span class="anchor" id="line-405"></span>stabbing unidimensional queries on the map. <span class="anchor" id="line-406"></span></li><li>The only missing detail for a good framework would be some mechanism <span class="anchor" id="line-407"></span>for compiling complex formulas into something fast to calculate. <span class="anchor" id="line-408"></span>The need arises for certain parts of the numerical model that our framework <span class="anchor" id="line-409"></span>user should code. They are employed by the inner loops of the <span class="anchor" id="line-410"></span>simulation algorithms, where performance is absolutely critical. After <span class="anchor" id="line-411"></span>examining our choices, we decided to design our own, very simple and <span class="anchor" id="line-412"></span>purpose-fitting functional language. The translator (compiler) for that <span class="anchor" id="line-413"></span>functional language, including scanner-parser, construction of the internal <span class="anchor" id="line-414"></span>AST, various optimization stages and code generation was implemented <span class="anchor" id="line-415"></span>in Python. <span class="anchor" id="line-416"></span><span class="anchor" id="line-417"></span></li></ul><p class="line874">Configuration, documentation, construction and deployment is also managed <span class="anchor" id="line-418"></span>using this language, through SCons, Epydoc and a few custom modules coded <span class="anchor" id="line-419"></span>by us. In all the cases, Python demonstrated to be a valuable <span class="anchor" id="line-420"></span><span class="anchor" id="line-421"></span><span class="anchor" id="line-422"></span><p class="line867"><span class="anchor" id="rcimrman"></span>  <span class="anchor" id="line-423"></span>
<h2 id="SfePy_-_Simple_Finite_Elements_in_Python">SfePy - Simple Finite Elements in Python</h2>
<span class="anchor" id="line-424"></span><span class="anchor" id="line-425"></span><p class="line867"><strong>by: Robert Cimrman and  Ondøej Èertík</strong> <span class="anchor" id="line-426"></span><span class="anchor" id="line-427"></span><p class="line867"><a class="http" href="../external.html?link=http://sfepy.org/">SfePy</a> is an open source (BSD license) finite element <span class="anchor" id="line-428"></span>analysis software designed to provide a flexible general finite element <span class="anchor" id="line-429"></span>modeling tool which is easily adaptable to solve problems defined in terms <span class="anchor" id="line-430"></span>of systems of PDEs. It is written almost exclusively in Python programming <span class="anchor" id="line-431"></span>language, with a few time-demanding parts in C wrapped by the interface <span class="anchor" id="line-432"></span>generator <a class="http" href="../external.html?link=http://www.swig.org/">SWIG</a>. Other notable features are its small <span class="anchor" id="line-433"></span>size (complete sources are just about 1.2 MB, April 2008), fast compilation, <span class="anchor" id="line-434"></span>problem description files in pure Python and problem description syntax <span class="anchor" id="line-435"></span>similar to a mathematical description &quot;on paper&quot;. <span class="anchor" id="line-436"></span><span class="anchor" id="line-437"></span><p class="line862">It relies primarily on <a class="http" href="../external.html?link=http://scipy.org/">NumPy/Scipy</a>, <span class="anchor" id="line-438"></span><a class="http" href="../external.html?link=http://pyparsing.wikispaces.com/">Pyparsing</a>, <span class="anchor" id="line-439"></span>and optionally on <a class="http" href="../external.html?link=http://matplotlib.sourceforge.net/">Matplotlib</a> <span class="anchor" id="line-440"></span>and <a class="http" href="../external.html?link=http://pytables.sourceforge.net/">Pytables</a>. <span class="anchor" id="line-441"></span><span class="anchor" id="line-442"></span><p class="line874">Its research applications include: shape optimization of closed <span class="anchor" id="line-443"></span>channels; multiscale modeling of a strongly heterogeneous porous media <span class="anchor" id="line-444"></span>(e.g. muscles, bones, brain) by the theory of homogenization; modeling <span class="anchor" id="line-445"></span>of so-called phononic materials, elastic periodic structures with strong <span class="anchor" id="line-446"></span>heterogeneities in the elasticity: in the homogenized medium, negative <span class="anchor" id="line-447"></span>eigenvalues of an effective mass tensor appear for certain frequency ranges, <span class="anchor" id="line-448"></span>leading to so-called band gaps in acoustic wave propagation; a Schroedinger <span class="anchor" id="line-449"></span>equation solver, that solves it for any potential in real space. <span class="anchor" id="line-450"></span><span class="anchor" id="line-451"></span><p class="line862">In the presentation we give a general information on SfePy, show a solution <span class="anchor" id="line-452"></span>of a simple problem and mention some examples from the fields above. The code <span class="anchor" id="line-453"></span>verification using the method of manufactured solutions (calculated by SymPy) <span class="anchor" id="line-454"></span>is also discussed. <span class="anchor" id="line-455"></span><span class="anchor" id="bottom"></span></div><p id="pageinfo" class="info" lang="en" dir="ltr">SciPy: EuroSciPy2008Abstracts  (last edited 2015-10-24 17:48:24 by <span title="">anonymous</span>)</p>

<div id="pagebottom"></div>
</div>


<div id="footer">
<ul class="editbar"><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbattachments" href="EuroSciPy2008Abstracts37dc.html?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="../external.html?link=http://localhost:8080/EuroSciPy2008Abstracts">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Subscribe User</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

<ul id="credits">
<li><a href="../external.html?link=http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="../external.html?link=http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="../external.html?link=http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="../external.html?link=http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>
</body>

<!-- Mirrored from localhost:8080/EuroSciPy2008Abstracts by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 29 Oct 2015 20:25:11 GMT -->
</html>

