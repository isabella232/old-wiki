<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!-- Mirrored from localhost:8080/ParallelProgramming?action=recoverpass by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 29 Oct 2015 23:19:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="edit_on_doubleclick" content="/">
<meta name="robots" content="noindex,nofollow">

<title>ParallelProgramming - SciPy wiki dump</title>
<script type="text/javascript" src="moin_static197/common/js/common.js"></script>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="moin_static197/modern/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="moin_static197/modern/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="moin_static197/modern/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="moin_static197/modern/css/projection.css">

<!-- css only for MS IE6/IE7 browsers -->
<!--[if lt IE 8]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/moin_static197/modern/css/msie.css">
<![endif]-->


<link rel="alternate" title="SciPy: ParallelProgramming" href="../external.html?link=http://localhost:8080/ParallelProgramming?diffs=1&amp;show_att=1&amp;action=rss_rc&amp;unique=0&amp;page=ParallelProgramming&amp;ddiffs=1" type="application/rss+xml">


<link rel="Start" href="AllPages.html">
<link rel="Alternate" title="Wiki Markup" href="../external.html?link=http://localhost:8080/ParallelProgramming?action=raw">
<link rel="Alternate" media="print" title="Print View" href="../external.html?link=http://localhost:8080/ParallelProgramming?action=print">
<link rel="Search" href="FindPage.html">
<link rel="Index" href="TitleIndex.html">
<link rel="Glossary" href="WordIndex.html">
<link rel="Help" href="HelpOnFormatting.html">
</head>

<body  lang="en" dir="ltr"><div style="background: white; width:100%; padding:2em;">This is an archival dump of old wiki content --- see <a href="http://scipy.org/">scipy.org</a> for current material</div>

<div id="header">


<form id="searchform" method="get" action="../external.html?link=http://localhost:8080/ParallelProgramming">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20"
    onfocus="searchFocus(this)" onblur="searchBlur(this)"
    onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search">
<input id="titlesearch" name="titlesearch" type="submit"
    value="Titles" alt="Search Titles">
<input id="fullsearch" name="fullsearch" type="submit"
    value="Text" alt="Search Full Text">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<ul id="username"><li><a href="ParallelProgramming456e.html?action=login" id="login" rel="nofollow">Login</a></li></ul>
<div id="locationline">
<div id="interwiki"><span><a href="AllPages.html" rel="nofollow">SciPy</a></span></div>

<ul id="pagelocation">
<li><a class="backlink" href="ParallelProgrammingb0ee.html?action=fullsearch&amp;context=180&amp;value=linkto%3A%22ParallelProgramming%22" rel="nofollow" title="Click to do a full-text search for this title">ParallelProgramming</a></li>
</ul>

</div>


<ul id="navibar">
<li class="wikilink"><a href="RecentChanges.html">RecentChanges</a></li><li class="wikilink"><a class="nonexistent" href="FindPage.html">FindPage</a></li><li class="wikilink"><a class="nonexistent" href="HelpContents.html">HelpContents</a></li><li class="current"><a href="ParallelProgramming.html">ParallelProgramming</a></li>
</ul>

<div id="pageline"><hr style="display:none;"></div>
<div id="message">
<p><div class="warning">This wiki is not enabled for mail processing.
Contact the owner of the wiki, who can enable email.</div></p><a class="clear-link" href="ParallelProgramming.html">Clear message</a>
</div>

<ul class="editbar"><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbattachments" href="ParallelProgramming37dc.html?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="../external.html?link=http://localhost:8080/ParallelProgramming">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Subscribe User</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867">
<h1 id="Parallel_Programming_with_numpy_and_scipy">Parallel Programming with numpy and scipy</h1>
<span class="anchor" id="line-2"></span><p class="line874">Multiprocessor and multicore machines are becoming more common, and it would be nice to take advantage of them to make your code run faster. numpy/scipy are not perfect in this area, but there are some things you can do. The best way to make use of a parallel processing system depend on the task you're doing and on the parallel system you're using. If you have a big complicated job or a cluster of machines, taking full advantage will require much thought. But many tasks can be parallelized in a fairly simple way. <span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><p class="line862">As the saying goes, &quot;<a class="http" href="../external.html?link=http://www.acm.org/ubiquity/views/v7i24_fallacy.html">premature optimization is the root of all evil</a>&quot;. Using a multicore machine will provide at best a speedup by a factor of the number of cores available. Get your code working first, before even thinking about parallelization. Then ask yourself whether your code actually needs to be any faster. Don't embark on the bug-strewn path of parallelization unless you have to. <span class="anchor" id="line-5"></span><span class="anchor" id="line-6"></span><p class="line867">
<h2 id="Simple_parallelization">Simple parallelization</h2>
<span class="anchor" id="line-7"></span><p class="line867">
<h3 id="Break_your_job_into_smaller_jobs_and_run_them_simultaneously">Break your job into smaller jobs and run them simultaneously</h3>
<span class="anchor" id="line-8"></span><p class="line874">For example, if you are analyzing data from a pulsar survey, and you have thousands of beams to analyze, each taking a day, the simplest (and probably most efficient) way to parallelize the task is to simply run each beam as a job. Machines with two processors can just run two jobs. No need to worry about locking or communication; no need to write code that knows it's running in parallel. You can have issues if the processes each need as much memory as your machine has, or if they are both IO heavy, but in general this is a simple and efficient way to parallelize your code - if it works. Not all tasks divide up this nicely. If your goal is to process a single image, it's not clear how to do this without a lot of work. <span class="anchor" id="line-9"></span><span class="anchor" id="line-10"></span><p class="line867">
<h3 id="Use_parallel_primitives">Use parallel primitives</h3>
<span class="anchor" id="line-11"></span><p class="line874">One of the great strengths of numpy is that you can express array operations very cleanly. For example to compute the product of the matrix A and the matrix B, you just do: <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line867"><span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><pre><span class="anchor" id="line-1"></span>&gt;&gt;&gt; C = numpy.dot(A,B)</pre><span class="anchor" id="line-16"></span><p class="line862">Not only is this simple and clear to read and write, since numpy knows you want to do a matrix dot product it can use an optimized implementation obtained as part of &quot;BLAS&quot; (the Basic Linear Algebra Subroutines). This will normally be a library carefully tuned to run as fast as possible on your hardware by taking advantage of cache memory and assembler implementation. But many architectures now have a BLAS that also takes advantage of a multicore machine. If your numpy/scipy is compiled using one of these, then dot() will be computed in parallel (if this is faster) without you doing anything. Similarly for other matrix operations, like inversion, singular value decomposition, determinant, and so on. For example, the open source library <a class="http" href="../external.html?link=http://math-atlas.sourceforge.net/">ATLAS</a> allows compile time selection of the level of parallelism (number of threads). The proprietary <a class="http" href="../external.html?link=http://www.intel.com/cd/software/products/asmo-na/eng/307757.htm">MKL</a> library from Intel offers the possibility to chose the level of parallelism at runtime.  <span class="anchor" id="line-17"></span>There is also the <a class="http" href="../external.html?link=http://www.tacc.utexas.edu/resources/software/software_downloads.php">GOTO</a> library that allow run-time selection of the level of parallelism. This is a commercial product but the source code is distributed free for academic use.  <span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span><p class="line874">Finally, scipy/numpy does not parallelize operations like <span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><p class="line867"><span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><pre><span class="anchor" id="line-1-1"></span>&gt;&gt;&gt; A = B + C
<span class="anchor" id="line-2"></span>&gt;&gt;&gt; A = numpy.sin(B)
<span class="anchor" id="line-3"></span>&gt;&gt;&gt; A = scipy.stats.norm.isf(B)</pre><span class="anchor" id="line-26"></span><p class="line874">These operations run sequentially, taking no advantage of multicore machines (but see below). In principle, this could be changed without too much work. OpenMP is an extension to the C language which allows compilers to produce parallelizing code for appropriately-annotated loops (and other things). If someone sat down and annotated a few core loops in numpy (and possibly in scipy), and if one then compiled numpy/scipy with OpenMP turned on, all three of the above would automatically be run in parallel. Of course, in reality one would want to have some runtime control - for example, one might want to turn off automatic parallelization if one were planning to run several jobs on the same multiprocessor machine. <span class="anchor" id="line-27"></span><span class="anchor" id="line-28"></span><p class="line867">
<h3 id="Write_multithreaded_or_multiprocess_code">Write multithreaded or multiprocess code</h3>
<span class="anchor" id="line-29"></span><p class="line862">Sometimes you can see how to break your problem into several parallel tasks, but those tasks need some kind of synchronization or communication. For example, you might have a list of jobs that can be run in parallel, but you need to gather all their results, do some summary calculation, then launch another batch of parallel jobs. There are two approaches to doing this in Python, using either multiple <a class="http" href="../external.html?link=http://en.wikipedia.org/wiki/Thread_(computer_science)">threads</a> or <a class="http" href="../external.html?link=http://en.wikipedia.org/wiki/Process_(computing)">processes</a>. <span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span><p class="line867">
<h4 id="Threads">Threads</h4>
<span class="anchor" id="line-32"></span><p class="line862">Threads are generally 'lighter' than processes, and can be created, destroyed and switched between faster than processes. They are normally preferred for taking advantage of multicore systems. However, multithreading with python has a key limitation; the <a class="http" href="../external.html?link=http://docs.python.org/api/threads.html">Global Interpreter Lock</a> (<a class="http" href="../external.html?link=http://effbot.org/pyfaq/what-is-the-global-interpreter-lock.htm">GIL</a>). For various reasons (a quick web search will turn up copious <a class="http" href="../external.html?link=http://blog.ianbicking.org/gil-of-doom.html">discussion</a>, not to say <a class="http" href="../external.html?link=http://mail.python.org/pipermail/python-3000/2007-May/007414.html">argument</a>, over <a class="http" href="../external.html?link=http://www.artima.com/weblogs/viewpost.jsp?thread=214235">why this exists</a> and <a class="http" href="../external.html?link=http://blog.snaplogic.org/?p=94">whether it's a good idea</a>), python is implemented in such a way that only one thread can be accessing the interpreter at a time. This basically means only one thread can be running python code at a time. This almost means that you don't take any advantage of parallel processing at all. The exceptions are few but important: while a thread is waiting for IO (for you to type something, say, or for something to come in the network) python releases the GIL so other threads can run. And, more importantly for us, while numpy is doing an array operation, python also releases the GIL. Thus if you tell one thread to do: <span class="anchor" id="line-33"></span><span class="anchor" id="line-34"></span><p class="line867"><span class="anchor" id="line-35"></span><span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><span class="anchor" id="line-38"></span><pre><span class="anchor" id="line-1-2"></span>&gt;&gt;&gt; print &quot;%s %s %s %s and %s&quot; %( (&quot;spam&quot;,) *3 + (&quot;eggs&quot;,) + (&quot;spam&quot;,) )
<span class="anchor" id="line-2-1"></span>&gt;&gt;&gt; A = B + C
<span class="anchor" id="line-3-1"></span>&gt;&gt;&gt; print A</pre><span class="anchor" id="line-39"></span><p class="line874">During the print operations and the % formatting operation, no other thread can execute. But during the A = B + C, another thread can run - and if you've written your code in a numpy style, much of the calculation will be done in a few array operations like A = B + C. Thus you can actually get a speedup from using multiple threads. <span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line862">The python threading module is part of the standard library and provides tools for multithreading. Given the limitations discussed above, it may not be worth carefully rewriting your code in a multithreaded architecture. But sometimes you can do multithreading with little effort, and in these cases it can be worth it. See <a href="Cookbook/Multithreading.html">Cookbook/Multithreading</a> for one example. <a class="http" href="../external.html?link=http://code.activestate.com/recipes/576519/">This recipe</a> provides a thread Pool() interface with the same API as that found for processes (below) which might also be of interest. There is also the <a class="http" href="../external.html?link=http://www.chrisarndt.de/projects/threadpool/">ThreadPool</a> module which is quite similar. <span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><p class="line867">
<h4 id="Processes">Processes</h4>
<span class="anchor" id="line-44"></span><p class="line862">One way to overcome the limitations of the GIL discussed above is to use multiple full processes instead of threads. Each process has it's own GIL, so they do not block each other in the same way that threads do. From python 2.6, the standard library includes a <a class="http" href="../external.html?link=http://docs.python.org/library/multiprocessing.html">multiprocessing</a> module, with the same interface as the threading module. For earlier versions of Python, this is available as the <a class="http" href="../external.html?link=http://pyprocessing.berlios.de/">processing</a> module (a backport of the multiprocessing module of python 2.6 for python 2.4 and 2.5 is in the works here: <a class="http" href="../external.html?link=http://code.google.com/p/python-multiprocessing">multiprocessing</a> ). It is possible to share memory between processes, including <a class="http" href="../external.html?link=http://coding.derkeiler.com/Archive/Python/comp.lang.python/2008-09/msg00937.html">numpy arrays</a>. This allows most of the benefits of threading without the problems of the GIL. It also provides a simple Pool() interface, which features map and apply commands similar to those found in the <a href="Cookbook/Multithreading.html">Cookbook/Multithreading</a> example. <span class="anchor" id="line-45"></span><span class="anchor" id="line-46"></span><p class="line867">
<h4 id="Comparison">Comparison</h4>
<span class="anchor" id="line-47"></span><p class="line874">Here is a very basic comparison which illustrates the effect of the GIL (on a dual core machine). <span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><p class="line867"><span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><pre><span class="anchor" id="line-1-3"></span>import numpy as np
<span class="anchor" id="line-2-2"></span>import math
<span class="anchor" id="line-3-2"></span>def f(x):
<span class="anchor" id="line-4"></span>    print x
<span class="anchor" id="line-5"></span>    y = [1]*10000000
<span class="anchor" id="line-6"></span>    [math.exp(i) for i in y]
<span class="anchor" id="line-7"></span>def g(x):
<span class="anchor" id="line-8"></span>    print x
<span class="anchor" id="line-9"></span>    y = np.ones(10000000)
<span class="anchor" id="line-10"></span>    np.exp(y)</pre><span class="anchor" id="line-61"></span><p class="line867"><span class="anchor" id="line-62"></span><span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><span class="anchor" id="line-67"></span><span class="anchor" id="line-68"></span><span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><span class="anchor" id="line-71"></span><span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span><span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><pre><span class="anchor" id="line-1-4"></span>from handythread import foreach
<span class="anchor" id="line-2-3"></span>from processing import Pool
<span class="anchor" id="line-3-3"></span>from timings import f,g
<span class="anchor" id="line-4-1"></span>def fornorm(f,l):
<span class="anchor" id="line-5-1"></span>    for i in l:
<span class="anchor" id="line-6-1"></span>        f(i)
<span class="anchor" id="line-7-1"></span>time fornorm(g,range(100))
<span class="anchor" id="line-8-1"></span>time fornorm(f,range(10))
<span class="anchor" id="line-9-1"></span>time foreach(g,range(100),threads=2)
<span class="anchor" id="line-10-1"></span>time foreach(f,range(10),threads=2)
<span class="anchor" id="line-11"></span>p = Pool(2)
<span class="anchor" id="line-12"></span>time p.map(g,range(100))
<span class="anchor" id="line-13"></span>time p.map(f,range(100))</pre><span class="anchor" id="line-76"></span><div><table><tbody><tr>  <td><p class="line862"> </td>
  <td><p class="line862"> 100 * g() </td>
  <td><p class="line862"> 10 * f() </td>
</tr>
<tr>  <td><span class="anchor" id="line-77"></span><p class="line862"> normal </td>
  <td><p class="line862"> <tt class="backtick">43.5s</tt> </td>
  <td><p class="line862"> <tt class="backtick">48s</tt> </td>
</tr>
<tr>  <td><span class="anchor" id="line-78"></span><p class="line862"> 2 threads </td>
  <td><p class="line862"> <tt class="backtick">31s</tt> </td>
  <td><p class="line862"> <tt class="backtick">71.5s</tt> </td>
</tr>
<tr>  <td><span class="anchor" id="line-79"></span><p class="line862"> 2 processes </td>
  <td><p class="line862"> <tt class="backtick">27s</tt> </td>
  <td><p class="line862"> <tt class="backtick">31.23</tt> </td>
</tr>
</tbody></table></div><span class="anchor" id="line-80"></span><p class="line862">For function <tt class="backtick">f()</tt>, which does not release the GIL, threading actually performs worse than serial code, presumably due to the overhead of context switching. However, using 2 processes does provide a significant speedup. For function <tt class="backtick">g()</tt> which uses numpy and releases the GIL, both threads and processes provide a significant speed up, although multiprocesses is slightly faster. <span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><p class="line867">
<h2 id="Sophisticated_parallelization">Sophisticated parallelization</h2>
<span class="anchor" id="line-83"></span><p class="line874">If you need sophisticated parallelism - you have a computing cluster, say, and your jobs need to communicate with each other frequently - you will need to start thinking about real parallel programming. This is a subject for graduate courses in computer science, and I'm not going to address it here. But there are some python tools you can use to implement the things you learn in that graduate course. (I am perhaps exaggerating - some parallelization is not that difficult, and some of these tools make it fairly easy. But do realize that parallel code is much more difficult to write and debug than serial code.) <span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><ul><li><p class="line891"><a class="http" href="../external.html?link=http://ipython.scipy.org/moin/IPython1">IPython1</a> <span class="anchor" id="line-86"></span></li><li><p class="line891"><a href="mpi4py.html">mpi4py</a> <span class="anchor" id="line-87"></span></li><li><p class="line891"><a class="http" href="../external.html?link=http://www.parallelpython.com/">parallel python</a> <span class="anchor" id="line-88"></span></li><li><p class="line891"><a class="http" href="../external.html?link=http://poshmodule.sourceforge.net/">POSH</a> <span class="anchor" id="line-89"></span></li></ul><span class="anchor" id="bottom"></span></div>
<div id="pagebottom"></div>
</div>


<div id="footer">
<ul class="editbar"><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbattachments" href="ParallelProgramming37dc.html?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="../external.html?link=http://localhost:8080/ParallelProgramming">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Subscribe User</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

<ul id="credits">
<li><a href="../external.html?link=http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="../external.html?link=http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="../external.html?link=http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="../external.html?link=http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>
</body>

<!-- Mirrored from localhost:8080/ParallelProgramming?action=recoverpass by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 29 Oct 2015 23:19:47 GMT -->
</html>

